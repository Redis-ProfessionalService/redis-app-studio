command_name[Text](Command Name),command_link[Text](Command Link),command_description[Text](Command Description)
EXISTS,"https://redis.io/commands/exists","Returns if key exists.  Since Redis 3.0.3 it is possible to specify multiple keys instead of a single one. In such a case, it returns the total number of keys existing. Note that returning 1 or 0 for a single key is just a special case of the variadic usage, so the command is completely backward compatible. The user should be aware that if the same existing key is mentioned in the arguments multiple times, it will be counted multiple times. So if somekey exists, EXISTS somekey somekey will return 2."
SET,"https://redis.io/commands/set","Set key to hold the string value. If key already holds a value, it is overwritten, regardless of its type. Any previous time to live associated with the key is discarded on successful SET operation."
GET,"https://redis.io/commands/get","Get the value of key. If the key does not exist the special value nil is returned. An error is returned if the value stored at key is not a string, because GET only handles string values."
EXPIRE,"https://redis.io/commands/expire","Set a timeout on key. After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is often said to be volatile in Redis terminology.  The timeout will only be cleared by commands that delete or overwrite the contents of the key, including DEL, SET, GETSET and all the *STORE commands. This means that all the operations that conceptually alter the value stored at the key without replacing it with a new one will leave the timeout untouched."
DEL,"https://redis.io/commands/del","Removes the specified keys. A key is ignored if it does not exist."
RENAME,"https://redis.io/commands/rename","Renames key to newkey. It returns an error when key does not exist. If newkey already exists it is overwritten, when this happens RENAME executes an implicit DEL operation, so if the deleted key contains a very big value it may cause high latency even if RENAME itself is usually a constant-time operation."
UNLINK,"https://redis.io/commands/unlink","This command is very similar to DEL: it removes the specified keys. Just like DEL a key is ignored if it does not exist. However the command performs the actual memory reclaiming in a different thread, so it is not blocking, while DEL is. This is where the command name comes from: the command just unlinks the keys from the keyspace. The actual removal will happen later asynchronously."
HSET,"https://redis.io/commands/hset","Sets field in the hash stored at key to value. If key does not exist, a new key holding a hash is created. If field already exists in the hash, it is overwritten.  As of Redis 4.0.0, HSET is variadic and allows for multiple field/value pairs."
HMGET,"https://redis.io/commands/hmget","Returns the values associated with the specified fields in the hash stored at key.  For every field that does not exist in the hash, a nil value is returned. Because non-existing keys are treated as empty hashes, running HMGET against a non-existing key will return a list of nil values."
HGETALL,"https://redis.io/commands/hgetall","Returns all fields and values of the hash stored at key. In the returned value, every field name is followed by its value, so the length of the reply is twice the size of the hash."
HDEL,"https://redis.io/commands/hdel","Removes the specified fields from the hash stored at key. Specified fields that do not exist within this hash are ignored. If key does not exist, it is treated as an empty hash and this command returns 0."
RPUSH,"https://redis.io/commands/rpush","Insert all the specified values at the tail of the list stored at key. If key does not exist, it is created as empty list before performing the push operation. When key holds a value that is not a list, an error is returned.  It is possible to push multiple elements using a single command call just specifying multiple arguments at the end of the command. Elements are inserted one after the other to the tail of the list, from the leftmost element to the rightmost element. So for instance the command RPUSH mylist a b c will result into a list containing a as first element, b as second element and c as third element."
LLEN,"https://redis.io/commands/llen","Returns the length of the list stored at key. If key does not exist, it is interpreted as an empty list and 0 is returned. An error is returned when the value stored at key is not a list."
LRANGE,"https://redis.io/commands/lrange","Returns the specified elements of the list stored at key. The offsets start and stop are zero-based indexes, with 0 being the first element of the list (the head of the list), 1 being the next element and so on.  These offsets can also be negative numbers indicating offsets starting at the end of the list. For example, -1 is the last element of the list, -2 the penultimate, and so on."
LINDEX,"https://redis.io/commands/lindex","Returns the element at index index in the list stored at key. The index is zero-based, so 0 means the first element, 1 the second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, -1 means the last element, -2 means the penultimate and so forth."
LINSERT,"https://redis.io/commands/linsert","Inserts element in the list stored at key either before or after the reference value pivot.  When key does not exist, it is considered an empty list and no operation is performed.  An error is returned when key exists but does not hold a list value."
LREM,"https://redis.io/commands/lrem","Removes the first count occurrences of elements equal to element from the list stored at key. The count argument influences the operation in the following ways: count > 0: Remove elements equal to element moving from head to tail; count < 0: Remove elements equal to element moving from tail to head; count = 0: Remove all elements equal to element.  For example, LREM list -2 'hello' will remove the last two occurrences of 'hello' in the list stored at list."
RPOP,"https://redis.io/commands/rpop","Removes and returns the last elements of the list stored at key.  By default, the command pops a single element from the end of the list. When provided with the optional count argument, the reply will consist of up to count elements, depending on the list's length."
LPUSH,"https://redis.io/commands/lpush","Insert all the specified values at the head of the list stored at key. If key does not exist, it is created as empty list before performing the push operations. When key holds a value that is not a list, an error is returned.  It is possible to push multiple elements using a single command call just specifying multiple arguments at the end of the command. Elements are inserted one after the other to the head of the list, from the leftmost element to the rightmost element. So for instance the command LPUSH mylist a b c will result into a list containing c as first element, b as second element and a as third element."
LPOP,"https://redis.io/commands/lpop","Removes and returns the first elements of the list stored at key.  By default, the command pops a single element from the beginning of the list. When provided with the optional count argument, the reply will consist of up to count elements, depending on the list's length."
LTRIM,"https://redis.io/commands/ltrim","Trim an existing list so that it will contain only the specified range of elements specified. Both start and stop are zero-based indexes, where 0 is the first element of the list (the head), 1 the next element and so on."
ZADD,"https://redis.io/commands/zadd","Adds all the specified members with the specified scores to the sorted set stored at key. It is possible to specify multiple score / member pairs. If a specified member is already a member of the sorted set, the score is updated and the element reinserted at the right position to ensure the correct ordering.  If key does not exist, a new sorted set with the specified members as sole members is created, like if the sorted set was empty. If the key exists but does not hold a sorted set, an error is returned.  The score values should be the string representation of a double precision floating point number. +inf and -inf values are valid values as well."
ZINCRBY,"https://redis.io/commands/zincrby","Increments the score of member in the sorted set stored at key by increment. If member does not exist in the sorted set, it is added with increment as its score (as if its previous score was 0.0). If key does not exist, a new sorted set with the specified member as its sole member is created."
ZREM,"https://redis.io/commands/zrem","Removes the specified members from the sorted set stored at key. Non existing members are ignored.  An error is returned when key exists and does not hold a sorted set."
ZRANGE,"https://redis.io/commands/zrange","Returns the specified range of elements in the sorted set stored at <key>.  ZRANGE can perform different types of range queries: by index (rank), by the score, or by lexicographical order.  The order of elements is from the lowest to the highest score. Elements with the same score are ordered lexicographically."
ZCARD,"https://redis.io/commands/zcard","Returns the sorted set cardinality (number of elements) of the sorted set stored at key."
GEOADD,"https://redis.io/commands/geoadd","Adds the specified geospatial items (longitude, latitude, name) to the specified key. Data is stored into the key as a sorted set, in a way that makes it possible to query the items with the GEOSEARCH command.  The command takes arguments in the standard format x,y so the longitude must be specified before the latitude. There are limits to the coordinates that can be indexed: areas very near to the poles are not indexable."
GEODIST,"https://redis.io/commands/geodist","Return the distance between two members in the geospatial index represented by the sorted set.  Given a sorted set representing a geospatial index, populated using the GEOADD command, the command returns the distance between the two specified members in the specified unit.  If one or both the members are missing, the command returns NULL."
GEOHASH,"https://redis.io/commands/geohash","Return valid Geohash strings representing the position of one or more elements in a sorted set value representing a geospatial index (where elements were added using GEOADD).  Normally Redis represents positions of elements using a variation of the Geohash technique where positions are encoded using 52 bit integers. The encoding is also different compared to the standard because the initial min and max coordinates used during the encoding and decoding process are different. This command however returns a standard Geohash in the form of a string as described in the Wikipedia article and compatible with the geohash.org web site."
GEORADIUS,"https://redis.io/commands/georadius","Return the members of a sorted set populated with geospatial information using GEOADD, which are within the borders of the area specified with the center location and the maximum distance from the center (the radius)."
GEOSEARCH,"https://redis.io/commands/geosearch","Return the members of a sorted set populated with geospatial information using GEOADD, which are within the borders of the area specified by a given shape. This command extends the GEORADIUS command, so in addition to searching within circular areas, it supports searching within rectangular areas."
XADD,"https://redis.io/commands/xadd","Appends the specified stream entry to the stream at the specified key. If the key does not exist, as a side effect of running this command the key is created with a stream value. The creation of stream's key can be disabled with the NOMKSTREAM option.  An entry is composed of a set of field-value pairs, it is basically a small dictionary. The field-value pairs are stored in the same order they are given by the user, and commands to read the stream such as XRANGE or XREAD are guaranteed to return the fields and values exactly in the same order they were added by XADD.  XADD is the only Redis command that can add data to a stream, but there are other commands, such as XDEL and XTRIM, that are able to remove data from a stream."
XDEL,"https://redis.io/commands/xdel","Removes the specified entries from a stream, and returns the number of entries deleted, that may be different from the number of IDs passed to the command in case certain IDs do not exist.  Normally you may think at a Redis stream as an append-only data structure, however Redis streams are represented in memory, so we are able to also delete entries. This may be useful, for instance, in order to comply with certain privacy policies."
XACK,"https://redis.io/commands/xack","The XACK command removes one or multiple messages from the Pending Entries List (PEL) of a stream consumer group. A message is pending, and as such stored inside the PEL, when it was delivered to some consumer, normally as a side effect of calling XREADGROUP, or when a consumer took ownership of a message calling XCLAIM. The pending message was delivered to some consumer but the server is yet not sure it was processed at least once. So new calls to XREADGROUP to grab the messages history for a consumer (for instance using an ID of 0), will return such message. Similarly the pending message will be listed by the XPENDING command, that inspects the PEL.  Once a consumer successfully processes a message, it should call XACK so that such message does not get processed again, and as a side effect, the PEL entry about this message is also purged, releasing memory from the Redis server."
XAUTOCLAIM,"https://redis.io/commands/xautoclaim","This command transfers ownership of pending stream entries that match the specified criteria. Conceptually, XAUTOCLAIM is equivalent to calling XPENDING and then XCLAIM, but provides a more straightforward way to deal with message delivery failures via SCAN-like semantics.  Like XCLAIM, the command operates on the stream entries at <key> and in the context of the provided <group>. It transfers ownership to <consumer> of messages pending for more than <min-idle-time> milliseconds and having an equal or greater ID than <start>."
XCLAIM,"https://redis.io/commands/xclaim","In the context of a stream consumer group, this command changes the ownership of a pending message, so that the new owner is the consumer specified as the command argument."
XGROUP,"https://redis.io/commands/xgroup","This command is used in order to manage the consumer groups associated with a stream data structure. Using XGROUP you can: Create a new consumer group associated with a stream; Destroy a consumer group; Remove a specific consumer from a consumer group; Set the consumer group last delivered ID to something else."
XINFO,"https://redis.io/commands/xinfo","This is an introspection command used in order to retrieve different information about the streams and associated consumer groups."
XLEN,"https://redis.io/commands/xlen","Returns the number of entries inside a stream. If the specified key does not exist the command returns zero, as if the stream was empty. However note that unlike other Redis types, zero-length streams are possible, so you should call TYPE or EXISTS in order to check if a key exists or not.  Streams are not auto-deleted once they have no entries inside (for instance after an XDEL call), because the stream may have consumer groups associated with it."
XPENDING,"https://redis.io/commands/xpending","Fetching data from a stream via a consumer group, and not acknowledging such data, has the effect of creating pending entries. This is well explained in the XREADGROUP command, and even better in our introduction to Redis Streams. The XACK command will immediately remove the pending entry from the Pending Entries List (PEL) since once a message is successfully processed, there is no longer need for the consumer group to track it and to remember the current owner of the message."
XRANGE,"https://redis.io/commands/xrange","The command returns the stream entries matching a given range of IDs. The range is specified by a minimum and maximum ID. All the entries having an ID between the two specified or exactly one of the two IDs specified (closed interval) are returned."
XREAD,"https://redis.io/commands/xread","Read data from one or multiple streams, only returning entries with an ID greater than the last received ID reported by the caller. This command has an option to block if items are not available, in a similar fashion to BRPOP or BZPOPMIN and others."
XREADGROUP,"https://redis.io/commands/xreadgroup","The XREADGROUP command is a special version of the XREAD command with support for consumer groups. Probably you will have to understand the XREAD command before reading this page will makes sense."
XREVRANGE,"https://redis.io/commands/xrevrange","This command is exactly like XRANGE, but with the notable difference of returning the entries in reverse order, and also taking the start-end range in reverse order: in XREVRANGE you need to state the end ID and later the start ID, and the command will produce all the element between (or exactly like) the two IDs, starting from the end side."
XTRIM,"https://redis.io/commands/xtrim","Time complexity: O(N), with N being the number of evicted entries. Constant times are very small however, since entries are organized in macro nodes containing multiple entries that can be released with a single deallocation.  XTRIM trims the stream by evicting older entries (entries with lower IDs) if needed.  Trimming the stream can be done using one of these strategies: MAXLEN: Evicts entries as long as the stream's length exceeds the specified threshold, where threshold is a positive integer; MINID: Evicts entries with IDs lower than threshold, where threshold is a stream ID."
MULTI,"https://redis.io/commands/multi","Marks the start of a transaction block. Subsequent commands will be queued for atomic execution using EXEC."
EXEC,"https://redis.io/commands/exec","Executes all previously queued commands in a transaction and restores the connection state to normal.  When using WATCH, EXEC will execute commands only if the watched keys were not modified, allowing for a check-and-set mechanism."
KEYS,"https://redis.io/commands/keys","Returns all keys matching pattern.  While the time complexity for this operation is O(N), the constant times are fairly low. For example, Redis running on an entry level laptop can scan a 1 million key database in 40 milliseconds."
TYPE,"https://redis.io/commands/type","Returns the string representation of the type of the value stored at key. The different types that can be returned are: string, list, set, zset, hash and stream."
SCAN,"https://redis.io/commands/scan","The SCAN command and the closely related commands SSCAN, HSCAN and ZSCAN are used in order to incrementally iterate over a collection of elements.  Since these commands allow for incremental iteration, returning only a small number of elements per call, they can be used in production without the downside of commands like KEYS or SMEMBERS that may block the server for a long time (even several seconds) when called against big collections of keys or elements."
FLUSHDB,"https://redis.io/commands/flushdb","The FLUSHDB command deletes all keys in the database."
MEMORY USAGE,"https://redis.io/commands/memory-usage","The MEMORY USAGE command reports the number of bytes that a key and its value require to be stored in RAM.  The reported usage is the total of memory allocations for data and administrative overheads that a key its value require.  For nested data types, the optional SAMPLES option can be provided, where count is the number of sampled nested values. By default, this option is set to 5. To sample the all of the nested values, use SAMPLES 0."
"*","https://redis.io/commands","Redis database commands reference documentation."
FT.CREATE,"https://redis.io/commands/ft.create/","Creates an index with the given schema definition."
FT.SUGADD,"https://redis.io/commands/ft.sugadd/","Adds a suggestion string to an auto-complete suggestion dictionary. This is disconnected from the index definitions, and leaves creating and updating suggestions dictionaries to the user."
FT.SUGGET,"https://redis.io/commands/ft.sugget/","Gets completion suggestions for a prefix."
FT.SUGDEL ,"https://redis.io/commands/ft.sugdel/","Deletes a string from a suggestion index."
FT.SYNUPDATE,"https://redis.io/commands/ft.synupdate/","Updates a synonym group."
FT.SYNDUMP,"https://redis.io/commands/ft.syndump/","Dumps the contents of a synonym group."
FT.SPELLCHECK,"https://redis.io/commands/ft.spellcheck/","Performs spelling correction on a query, returning suggestions for misspelled terms."
FT.DICTADD,"https://redis.io/commands/ft.dictadd/","Adds terms to a dictionary."
FT.DICTDEL,"https://redis.io/commands/ft.dictdel/","Deletes terms from a dictionary."
FT.INFO,"https://redis.io/commands/ft.info/","Returns information and statistics on the search index."
FT.SEARCH,"https://redis.io/commands/ft.search/","Searches the index with a textual query, returning either documents or just ids."
FT.AGGREGATE,"https://redis.io/commands/ft.aggregate/","Runs a search query on an index, and performs aggregate transformations on the results, extracting statistics etc from them. See the full documentation on aggregations for further details."
FT.DROPINDEX,"https://redis.io/commands/ft.dropindex/","Deletes the search index."
"FT.*","https://redis.io/commands/?group=search","RediSearch commands reference documentation."
GRAPH.QUERY,"https://redis.io/commands/graph.query/","Executes the given query against a specified graph."
GRAPH.DELETE,"https://redis.io/commands/graph.delete/","Completely removes the graph and all of its entities."
GRAPH.LIST,"https://redis.io/commands/graph.list/","Lists all graph keys in the keyspace."
"GRAPH.*","https://redis.io/commands/?group=graph","RedisGraph commands reference documentation."
JSON.SET,"https://redis.io/commands/json.set/","Sets the JSON value at path in key.  For new Redis keys the path must be the root. For existing keys, when the entire path exists, the value that it contains is replaced with the json value."
JSON.GET,"https://redis.io/commands/json.get/","Return the value at path in JSON serialized form. This command accepts multiple path s, and defaults to the value's root when none are given."
JSON.DEL,"https://redis.io/commands/json.del/","Delete a value. The path defaults to root if not provided. Non-existing keys and paths are ignored. Deleting an object's root is equivalent to deleting the key from Redis."
"JSON.*","https://redis.io/commands/?group=json","RedisJSON commands reference documentation."
TS.CREATE,"https://redis.io/commands/ts.create/","Create a new time-series."
TS.ALTER,"https://redis.io/commands/ts.alter/","Update the retention, labels of an existing key. The parameters are the same as TS.CREATE."
TS.ADD,"https://redis.io/commands/ts.add/","Append (or create and append) a new sample to the series."
TS.MADD ,"https://redis.io/commands/ts.madd/","Append new samples to a list of series."
TS.INCRBY,"https://redis.io/commands/ts.incrby/","Creates a new sample that increments the latest sample's value."
TS.DECRBY,"https://redis.io/commands/ts.decrby/","Creates a new sample that decrements the latest sample's value."
TS.CREATERULE,"https://redis.io/commands/ts.createrule/","Create a compaction rule."
TS.DELETERULE,"https://redis.io/commands/ts.deleterule/","Delete a compaction rule."
TS.RANGE,"https://redis.io/commands/ts.range/","Query a range in forward or reverse directions."
TS.REVRANGE,"https://redis.io/commands/ts.mrevrange/","Query a range in forward or reverse directions."
TS.MRANGE,"https://redis.io/commands/ts.mrange/","Query a range across multiple time-series by filters in forward or reverse directions."
TS.MREVRANGE,"https://redis.io/commands/ts.mrevrange/","Query a range across multiple time-series by filters in forward or reverse directions."
TS.GET,"https://redis.io/commands/ts.get/","Get the last sample."
TS.MGET,"https://redis.io/commands/ts.mget/","Get the last samples matching the specific filter."
TS.INFO,"https://redis.io/commands/ts.info/","Returns information and statistics on the time-series."
TS.QUERYINDEX,"https://redis.io/commands/ts.queryindex/","Get all the keys matching the filter list."
"TS.*","https://redis.io/commands/?group=timeseries","RedisTimeSeries commands reference documentation."